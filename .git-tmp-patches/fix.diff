commit 15d39ac95e50f37bcdbbd2c20d2ed0b2e15098f7
Author: parasquid <git@parasquid.com>
Date:   Wed Aug 27 14:47:51 2025 +0800

    fix(sync): rethrow after all mail parse fallbacks fail
    
    Why: When parsing still fails after binary/UTF-8 sanitized/scrubbed attempts, callers may want to handle or skip the item differently; rethrowing surfaces the error instead of silently creating a dummy message.
    
    What:\n- Track last exception in parse_mail_safely and raise it after all fallback strategies fail.\n- Keep warnings with mailbox and UID context for easier triage.

diff --git a/core/sync.rb b/core/sync.rb
index 40b4dc5..dee54fb 100755
--- a/core/sync.rb
+++ b/core/sync.rb
@@ -47,6 +47,40 @@ rescue JSON::GeneratorError, Encoding::UndefinedConversionError, Encoding::Inval
   value.is_a?(Array) ? "[]" : "\"\""
 end
 
+# Parse raw RFC822/IMAP payload into a Mail object safely.
+# Returns a Mail::Message or nil on parse/encoding errors, logging a warning.
+def parse_mail_safely(raw, mbox_name:, uid:)
+  str = raw.to_s
+  # 1) Try as binary bytes
+  begin
+    return Mail.read_from_string(str.b)
+  rescue ArgumentError, Encoding::InvalidByteSequenceError, Encoding::UndefinedConversionError => e1
+    warn "mail parse error (binary) mailbox=#{mbox_name} uid=#{uid}: #{e1.class}: #{e1.message}; retrying with UTF-8 sanitized"
+    last_error = e1
+  end
+
+  # 2) Try as sanitized UTF-8 (replace invalid/undef)
+  begin
+    sanitized = safe_utf8(str)
+    return Mail.read_from_string(sanitized)
+  rescue ArgumentError, Encoding::InvalidByteSequenceError, Encoding::UndefinedConversionError => e2
+    warn "mail parse error (sanitized UTF-8) mailbox=#{mbox_name} uid=#{uid}: #{e2.class}: #{e2.message}; retrying with scrubbed UTF-8"
+    last_error = e2
+  end
+
+  # 3) Try scrubbed UTF-8 (replace problematic sequences)
+  begin
+    scrubbed = str.dup.force_encoding("UTF-8").scrub
+    return Mail.read_from_string(scrubbed)
+  rescue => e3
+    warn "mail parse error (scrubbed) mailbox=#{mbox_name} uid=#{uid}: #{e3.class}: #{e3.message}; rethrowing"
+    last_error = e3
+  end
+
+  # 4) Last resort: surface the failure to the caller for custom handling
+  raise(last_error || ArgumentError.new("unparseable message for mailbox=#{mbox_name} uid=#{uid}"))
+end
+
 # patch only this instance of Net::IMAP::ResponseParser
 def patch(gmail_imap)
   class << gmail_imap.instance_variable_get(:@parser)
@@ -356,7 +390,7 @@ module NittyMail
                 attrs = fd.attr
                 next unless attrs
                 raw = attrs["BODY[]"] || attrs["RFC822"]
-                mail = Mail.read_from_string(raw)
+                mail = parse_mail_safely(raw, mbox_name: mbox_name, uid: uid)
                 uid = attrs["UID"]
                 flags_json = attrs["FLAGS"].to_json
                 log_processing(mbox_name:, uid:, mail:, flags_json:, progress: progress)
